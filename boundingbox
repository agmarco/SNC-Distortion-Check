#!/usr/bin/env python
import argparse

import sys
import scipy
import math
import numpy as np
import file_io

from utils import print_optimization_result
import matplotlib.pyplot as plt
import affine

from visualization import scatter3
from utils import split_file_variable_arg


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('points1540')
    args = parser.parse_args()

    p = file_io.load_points(args.points1540)['points']

    p = p[:, np.logical_and(p[0, :] > -20, p[0, :] < 20)]
    p = p[:, np.logical_and(p[1, :] > -140, p[1, :] < -100)]
    p = p[:, np.logical_and(p[2, :] > -80, p[2, :] < -25)]

    pm = p.copy()
    pm = pm[:, np.logical_and(pm[0, :] > -5, pm[0, :] < 5)]
    pm = pm[:, np.logical_and(pm[1, :] > -125, pm[1, :] < -115)]
    pm = pm[:, np.logical_and(pm[2, :] > -65, pm[2, :] < -40)]

    p = p - pm

    def f(tpx):
        rotation_matrix = affine.rotation(*tpx)
        p_rotated = affine.apply_affine(rotation_matrix, p)
        return np.prod(np.max(p_rotated, axis=1) - np.min(p_rotated, axis=1))


    x0 = np.array([0.0, 0.0, 0.0])
    options = {
        'xtol': 1e-15,
        'ftol': 1e-20,
        'maxiter': 4000,
    }
    result = scipy.optimize.minimize(f, x0, method='Nelder-Mead', options=options)
    print_optimization_result(result)

    rotation_matrix = affine.rotation(*result.x)
    p_rotated = affine.apply_affine(rotation_matrix, p)

    print([180/math.pi*xx for xx in result.x])
    print(np.max(p_rotated, axis=1) - np.min(p_rotated, axis=1))

    label_to_points = {'middle 27': p, 'middle 27 rotated': p_rotated}
    scatter3(label_to_points)
    plt.title(str(np.max(p_rotated, axis=1) - np.min(p_rotated, axis=1)))

    plt.show()

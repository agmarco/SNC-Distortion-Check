#!/usr/bin/env python
import sys

import dicom
import scipy.io

from feature_detection import convolution_feature_detection
import affine


if __name__ == '__main__':
    if len(sys.argv) != 3:
        print('Usage: detectfeatures INPUTMAT OUTPUTMAT')
        sys.exit(1)

    input_data = scipy.io.loadmat(sys.argv[1])
    voxels = input_data['voxels']
    irc_to_patient_xyz_transform = input_data['irc_to_patient_xyz_transform']

    # TODO: derive these values from the DICOM file + the orientation of the
    # data.  Currently, this assumes that the voxel's line up with the primary
    # axes, and thus we can create a kernel that is oriented with the ijk-axes
    # and it will work; this would fail, e.g. if the pixel spacing along one
    # dimension was drastically different, and the axes are swapped
    nr_row, nr_column, nr_slice, threshold_frac = 3, 3, 3, 0.6

    points_in_irc = convolution_feature_detection(voxels, nr_row, nr_column, nr_slice, threshold_frac)
    points_in_patient_xyz = affine.apply_affine(irc_to_patient_xyz_transform, points_in_irc)

    output_mat_filename = sys.argv[2]
    scipy.io.savemat(output_mat_filename, {'points': points_in_patient_xyz})

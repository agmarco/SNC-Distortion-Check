#!/usr/bin/env python
import argparse

import numpy as np
import scipy
import affine
from points_utils import categorize, metrics
from utils import print_optimization_result, print_xyztpx

import file_io


def middle_1(points, center, spacing):
    return _middle_xx(points, center, spacing, 0.5)


def middle_27(points, center, spacing):
    return _middle_xx(points, center, spacing, 1.5)


def _middle_xx(points, center, spacing, factor):
    pm = points.copy()

    pm = pm[:, np.logical_and(
        pm[0, :] > center[0] - factor*spacing,
        pm[0, :] < center[0] + factor*spacing
    )]

    pm = pm[:, np.logical_and(
        pm[1, :] > center[1] - factor*spacing,
        pm[1, :] < center[1] + factor*spacing
    )]

    pm = pm[:, np.logical_and(
        pm[2, :] > center[2] - factor*spacing,
        pm[2, :] < center[2] + factor*spacing
    )]

    return pm


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('cad', help='Input path to read CAD points-file')
    parser.add_argument('points', help='Input path to read input points-file')
    parser.add_argument('output', help='Output path to write registered CAD points-file')
    args = parser.parse_args()

    cad_points = file_io.load_points(args.cad)['points']
    algorithm_points = file_io.load_points(args.points)['points']

    # these are hard coded for now
    spacing = 15.0
    center = np.array([0, -120, -50], dtype=float)

    cad_27 = middle_27(cad_points, center, spacing)
    algorithm_27 = middle_27(algorithm_points, center, spacing)

    assert cad_27.shape[1] == 27
    assert algorithm_27.shape[1] == 27

    def f(xyztpx):
        affine_matrix = affine.translation_rotation(*xyztpx)
        cad_27_registered = affine.apply_affine(affine_matrix, cad_27)
        FN_A, TP_A, TP_B, FP_B = categorize(cad_27_registered, algorithm_27, lambda bmag: 2.0)
        FLEs = np.linalg.norm(TP_A - TP_B, axis=0)
        assert FLEs.shape[0] == 27
        return np.sqrt(np.sum(np.power(FLEs, 2)))

    x0 = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
    options = {
        'xtol': 1e-15,
        'ftol': 1e-20,
        'maxiter': 4000,
    }
    result = scipy.optimize.minimize(f, x0, method='Nelder-Mead', options=options)
    print_optimization_result(result)

    if not result.success:
        raise ValueError('Optimization did not succeed')
    print_xyztpx(result.x)

    affine_matrix = affine.translation_rotation(*result.x)
    cad_registered = affine.apply_affine(affine_matrix, cad_points)

    file_io.save_points(args.output, {
        'points': cad_registered,
    })
